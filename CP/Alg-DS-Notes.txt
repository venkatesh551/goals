----
23rd :  Bubble-sort, selection-sort : wikipedia, 
    solve Problems : HE, HR

Read Theory about insertion sort : wikipedia
    solve Problems : HE, HR, 

Read Theory about Merge-sort : wikipedia, sedgewick-exercises
    solve Problems : SPOJ, edx, HE, 

Heap-sort : wikipedia, CLRS-exercises, sedgewick-exercises
    solve Problems : SPOJ, edx, HE, 
     
Read theory about Quick Sort : wikipedia, CLRS-exercises, sedgewick-exercises   
    solve Problems : edx, HE,

Read theory about (Counting sort, Bucket sort, Radix Sort) : wikipedia, CLRS book-exercises
    solve Problems : edx, HE,

CLRS book-part2 : order-statistics 
    exercises, 


Searching : linear, Binary, Ternary

Resume EDX : Go through the vedio one more time
Solve edx problems


edx : Graph-Theory :
--------------------



References:
-----------

https://www.hackerearth.com/practice/algorithms/sorting/
https://www.hackerrank.com/domains/algorithms/arrays-and-sorting
http://www.spoj.com/problems/MERGSORT/
https://www.hackerrank.com/challenges/quicksort2
https://www.codechef.com/problems/SORTING




If you're changing the world, you're working on important things. You're excited to get up in the morning.

You never lose a dream. It just incubates as a hobby.









https://github.com/haseebr/competitive-programming/tree/master/Materials

If the input array is already sorted, insertion sort performs 
as few as n-1 comparisons, thus making insertion sort more efficient 
when given sorted or "nearly sorted" arrays.


Merge sort is often the best choice for sorting a linked list: in this situation it is relatively easy to implement a merge sort in such a way that it requires only Θ(1) extra space, and the slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.

-----

Discrete math of different kinds. More specifically:
Logic and proof technologies, like math induction or proof by contrapositive.
Graphs of all kinds.
Set theory. Basics, no need to distinguish infinite sets cardinality or learn ZFC. Inclusion–exclusion principle, for instance.
Combinators. Binomial coefficients, different tricks about calculating amount of something (similar tricks can be used in programming to make problem easier to solve) - all are very useful.
Asymptotical analysis - again, basics. For example, remembering that sum of harmonic series is logarithm is very useful (e.g. in naive Eratosthenes sieve)
Probability theory - useful in corresponding problems or when you're trying to invent randomized algorithm. Also a good excercise for your brain.
Number theory - it's useful sometimes in corresponding problems. Not very useful outside of number theory problems.

---


Don't delegate: Do everything you can yourself to make things go faster.
Don't get in the way if you're not adding value. Let the people actually doing the work talk to each other while you go do something else.
Don't be a bureaucrat.
Ideas are more important than age. Just because someone is junior doesn't mean they don't deserve respect and cooperation.
The worst thing you can do is stop someone from doing something by saying, "No. Period." If you say no, you have to help them find a better way to get it done







