

Read book and solve questions from 
The C Programming Language
Book by Brian Kernighan and Dennis Ritchie.
After that write code on any online coding contest website.


For C++ :

https://isocpp.org/blog/2014/09/templates-series

https://isocpp.org/wiki/faq/templates#overview-templates

First read book  Programming: Principles and Practice Using C++  Book by Bjarne Stroustrup then

C++ Primer Book by  Josée Lajoie and Stanley B. Lippman

---

https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers
http://thbecker.net/articles/rvalue_references/section_08.html#footnote_1



skill acquisition :
-------------------

The original model proposes that a student passes through five distinct stages: novice, competence, proficiency, expertise, and mastery.


In the novice stage, a person follows rules as given, without context, with no sense of responsibility beyond following the rules exactly. 

Competence develops when the individual develops organizing principles to quickly access the particular rules that are relevant to the specific task at hand; hence, competence is characterized by active decision making in choosing a course of action. 

Proficiency is shown by individuals who develop intuition to guide their decisions and devise their own rules to formulate plans. 

The progression is thus from rigid adherence to rules to an intuitive mode of reasoning based on tacit knowledge.

Michael Eraut summarized the five stages of increasing skill as follows:[2]

1. Novice
"rigid adherence to taught rules or plans"
no exercise of "discretionary judgment"

2. Advanced beginner
limited "situational perception"
all aspects of work treated separately with equal importance

3. Competent
"coping with crowdedness" (multiple activities, accumulation of information)
some perception of actions in relation to goals
deliberate planning
formulates routines

4. Proficient
holistic view of situation
prioritizes importance of aspects
"perceives deviations from the normal pattern"
employs maxims for guidance, with meanings that adapt to the situation at hand

5. Expert
transcends reliance on rules, guidelines, and maxims
"intuitive grasp of situations based on deep, tacit understanding"
has "vision of what is possible"
uses "analytical approaches" in new situations or in case of problems























    


Template (C++)
-------------




Function templates :
--------------------
    syntax for declaring function templates with type parameters is:

        template <class identifier> function_declaration;
        template <typename identifier> function_declaration;

Both expressions have the same meaning and behave in exactly the same way.
The latter form was introduced to avoid confusion,
since a type parameter need not be a class. (It can also be a basic type)

The composition offered by templates is type-safe.
    
max example

templates are introduced with the primary focus on techniques needed for the design,
implementation, and use of the standard library

Every major standard-library abstraction is represented as a template 
(for example, string, ostream , regex , complex , list , map , 
unique_ptr , thread , future , tuple , and function)

Class templates :
-----------------

A class template provides a specification for generating classes based on parameters.


Variable templates : (since C++14)
-------------------


Template specialization:
---------------------------    
When a function or class is instantiated from a template, 
a specialization of that template is created by the compiler 
for the set of arguments used,


Variadic templates
--------------------
C++11 introduced variadic templates, which can take a variable 
number of arguments in a manner somewhat similar to variadic 
functions such as std::printf. 
Both function templates and class templates can be variadic.


Drawbacks to the use of templates: 
-----------------------------------
1. Many compilers lack clear instructions when they detect a template definition error.
2. It can be difficult to debug code that is developed using templates



Defining a Template
--------------------
A class generated from a class template is a perfectly ordinary class. Thus, use of a template does
not imply any run-time mechanisms beyond what is used for an equivalent ‘‘handwritten’’ class. In
fact, using a template can lead to a decrease of code generated because code for a member function
of a class template is only generated if that member is used.

A template is a specification of how to generate something
given suitable template arguments;

don’t care much whether a class or a function is generated.

the rules for templates apply equally to class templates and function
templates.

when trying to understand a template,
it is often useful to imagine its behavior for a particular type argument
before trying to comprehend the template in its full generality


Members of a class template are declared and defined exactly as they would have been for a
non-template class. A template member need not be defined within the template class itself.


Members of a template class are themselves templates parameterized by the parameters
of their template class.

example:
    
It is not possible to overload a class template name, so if a class template is declared in a scope, no other entity can be declared there with the same name.


A type used as a template argument must provide the interface expected by the template.


Template Instantiation:
----------------------

The process of generating a class or a function from a 
template plus a template argument list is often called template instantiation


Type Checking
----------------
Template instantiation takes a template plus a set of template 
arguments and generates code from them.

Type checking is done on the code generated by template 
instantiation (exactly as if the programmer had expanded the templates by hand).

This mismatch between what the programmer sees/writes and what the compiler type checks can be a major problem, and we need to design our programs to minimize its consequences.

The fundamental weakness of the template mechanism is that it is not possible to directly
express requirements on a template argument.


Type Equivalence
-----------------

When using the same set of template arguments for a template, 
we always refer to the same generated type.

Aliases do not introduce new types.

vector<unsigned char> s3;

using Uchar = unsigned char;

vector<Uchar> s4;


Types generated from a single template by different template arguments 
are different types. 
In particular, generated types from related arguments are not automatically related.

For example,
assume that a Circle is a kind of Shape :
Shape∗ p {new Circle(p,100)};
vector<Shape>∗ q {new vector<Circle>{}};
vector<Shape> vs {vector<Circle>{}};
vector<Shape∗> vs {vector<Circle∗>{}};
// Circle* converts to Shape*
// error : no vector<Circle>* to vector<Shape>* conversion
// error : no vector<Circle> to vector<Shape> conversion
// error : no vector<Circle*> to vector<Shape*> conversion


Error Detection :
-----------------

A template is defined and then later used in combination with a 
set of template arguments. When
the template is defined, the definition is checked for syntax errors and possibly also for other errors that can be detected in isolation from a particular set of template arguments

A compiler can catch simple semantic errors at the point of 
definition or later at the point of use.

Errors that relate to the use of template parameters cannot be detected until the template is used.


Class Template Members
------------------------

* Data Members

A non- static data member can be initialized in its definition or in a constructor

* Member Functions

a non- static member function of a class template can be defined in-class
or outside the class

a member function of a template can be virtual or not. However, a virtual member func-
tion cannot also be a member function template


* Templates and virtual
------------------------
A member template cannot be virtual .

class Shape {
    // ...
    template<typename T>
    virtual bool intersect(const T&) const =0;
};



"Avoid nested types in templates unless they genuinely rely 
on every template parameter."

Function Templates
----------------------

When a function template is called, the types of the function arguments 
determine which version of
the template is used; that is, the template arguments are 
deduced from the function arguments.

Function templates are essential for writing generic algorithms to be applied to a wide variety of
container types. The ability to deduce template arguments for a call from the func-
tion arguments is crucial.

Note that class template parameters are never deduced.


If a template argument cannot be deduced from the function arguments, we must specify
it explicitly.

The syntax for static_cast , dynamic_cast , etc matches the 
explicitly qualified function template syntax.

If a template parameter can be deduced from more than one function argument, the same type
must be the result of each deduction. Otherwise, the call is an error.







    






















In the standard library, string is a synonym for basic_string<char>

using string = std::basic_string<char>;











ETRADE 22120344984096

hdfc 50100089428252
